let img = 'data:image/png;base64,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';

const SPEC = (() => {
    const SPRITES = `
id  |x|y |w |h |note
t0  |0|0 |7 |  |tail side view
j0  |1|0 |20|  |articulated junction (280)
a   |2|  |  |17|axels
a0  | |0 |16|  |pneumatic rear
a1  | |1 |17|  |springs rear (255/66)
a2  | |2 |15|  |ifa rear (211)
a3  | |3 |16|  |pneumatic front
a4  | |4 |17|  |springs front (255/66)
a5  | |5 |15|  |ifa front (211)
w   |3|  |  |21|windows
w0  | |0 |25|  |sliderless
w1  | |1 |25|  |small sliders
w2  | |2 |25|  |large sliders
w3  | |3 |16|  |narrow
w4  | |4 |14|  |narrow sliderless
w5  | |5 |16|  |short, narrow
w6  | |6 |7 |  |tiny
w7  | |7 |30|  |wide sliderless (255.72)
w8  | |8 |30|  |wide
l   |4|  |  |17|hatches
l0  | |0 |20|  |tall
l1  | |1 |20|  |batt. (260.50)
l2  | |2 |20|  |short
l3  | |3 |20|  |fuel tank (260.50)
l4  | |4 |13|  |exhaust grill
l5  | |5 |13|  |radiator grill
l00 | |9 |39|  |double
l000| |10|58|  |tripple
l6  | |11|39|  |underfloor engine (260/63/80)
d   |5|  |  |  |doors
d0  | |0 |16|  |hinged tall (255.72)
d1  | |1 |16|  |hinged short  (256.54)
d2  | |2 |16|  |sliding rear (250.59)
d3  | |3 |16|  |sliding front (250.59)
d4  | |4 |22|  |folding front (260.50)
d5  | |5 |22|  |gliding (280.64)
d6  | |6 |24|  |gliding wide (263.00)
d7  | |7 |22|  |folding (260.50)
d8  | |8 |16|  |steyr (old 256)
d9  | |9 |16|  |folding front (266)
h   |6|  |7 |  |head side view
h0  | |0 |  |  |steel bumper
h1  | |1 |  |  |plastic bumper (250.59)
f   |7|  |  |  |frontal view
f0  | |0 |42|  |2 headlamps
f1  | |1 |42|  |4 headlamps
f2  | |2 |42|  |plastic bumper (250.59)
r   |8|  |  |  |rearside view
r0  | |0 |38|  |engine underflor
r1  | |1 |38|  |rear engine
s   |9|  |16|  |roof elements
s0  | |0 |10|  |rear
s1  | |1 |  |  |wide hatch
s2  | |2 |  |  |hatch
s3  | |3 |  |  |vent
s4  | |4 |  |  |blind
s5  | |5 |9 |  |front
`.split('\n')
        .filter(v => v && '' !== v.trim())
        .slice(1)
        .map(l => l.split('|').map(v => v.trim()))
        .map(([id, x, y, w, h, note]) => [id, {x, y, w, h, note, baseline: 'al'.indexOf(id[0]) >= 0 ? 'bottom' : 'top'}]);

    const LIVREYS = `
id|gradient                                                                 |note
c1|#E19000  0px 42px,   transparent 42px                                    |RAL 1006
c2|white    10px 20px,  #3B77B3 20px 32px, white 32px 42px, transparent 42px|DDR
c3|#e6d2b5  10px 30px,  rgb(134,26,34) 30px 42px, transparent 42px          |USSR 255
c4|blue     30px,  #e6d2b5 30px 42px, transparent 42px                 |dark blue
c5|rgb(134,26,34) 10px 30px, #e6d2b5 30px 42px, transparent 42px            |USSR 250
c6|#cc3300  10px 30px,  #e6d2b5 30px 42px, transparent 42px                 |250.59
c7|white    10px 30px,  #3B77B3 30px 42px, transparent 42px                 |cyan bottom
c8|#FCE10B  10px 30px,  #F62803 30px 42px, transparent 42px                 |Warszawa
`.split('\n')
        .filter(v => v && '' !== v.trim())
        .slice(1)
        .map(l => l.split('|').map(v => v.trim()))
        .map(([id, rules, note]) => [id, { rules, note }]);

    const _var = { dx: -42, dy: -47 };
    const cache = {};
    
    function _genSpritesCSS() {
        return SPRITES.map(([id, { x, y, w, h, baseline, note }]) => {
            const selector = `:checked[value${1 < id.length ? '' : '^'}="${id}"] ~ .shadow .${baseline}, .${id}`;
            const xexpr = x !== '0' ? `calc(var(--dx)${x === 1 ? '' : ` * ${x}`} - 1px)` : x;
            const yexpr = y !== '0' 
                ? `calc(var(--dy)${y === 1 ? '' : ` * ${y}`}${baseline === 'bottom' ? ' - 29px' : ''})` 
                : baseline === 'bottom' ? '-29px' : y;

            const rules = [
                x && y 
                    ? `background-position: ${xexpr} ${yexpr}`
                    : x 
                        ? `background-position-x: ${xexpr}`
                        : y 
                            ? `background-position-y: ${yexpr}` 
                            : '',
                w && `width: ${w}px`,
                h && `min-height: ${h}px`
            ].filter(Boolean); // Directly filters falsy values like empty strings

            return rules.length ? `${selector} { ${rules.join('; ')}; }/* ${note} */` : '';
        }).filter(Boolean).join('\n'); // Filters out empty results and joins rules
    }
    
    function _genInlineSprites() {
        return SPRITES.reduce((acc, [id, { x, y, w, baseline }]) => {
            const xexpr = `${_var.dx * x - 1}px`;
            const yexpr = `${_var.dy * y}${y > 0 ? 'px' : ''}`;
            
            const rules = [
                baseline !== 'bottom' ? '/*top*/' : '',
                x && y ? `background-position: ${xexpr} ${yexpr}` :
                x ? `background-position-x: ${xexpr}` :
                y ? `background-position-y: ${yexpr}` : '',
                w ? baseline === 'bottom' 
                    ? `padding-left: ${w}px; margin-left: ${-w}px` 
                    : `padding-right: ${w}px` : ''
            ].filter(Boolean); // Removes falsy values directly

            if (rules.length) {
                acc[id] = rules.join('; ') + ';';
            }
            return acc;
        }, {});
    }
    
    const imgType = Object.freeze({
        inline: img,
        file: 'tiles.png'
    });
    
    const genesys = {
        'bus0': 't0 d7 w2 a0 w2 l1 d7 w2 l3 w2 a3 d4 h0 f0 h0 w3 l2 w2 a3 w2 l2 w2 w2 w2 a0 w2 l2 t0 r0 c1',
        'bus1': 't0 w4 l4 d0 w7 a1 w7 w7 l000 w7 a4 d0 h0 f1 h0 l0 w3 w8 a4 w7 l000 w8 w7 a1 w8 l5 t0 r1 c2',
        'bus2': 't0 w4 l4 w4 w8 a1 w8 w8 l000 w8 a4 d0 h0 f1 h0 w3 l0 w8 a4 w8 l000 w8 w8 a1 w8 l5 t0 r1 c3',
        'bus3': 't0 w6 d0 w8 a2 w8 l00 w2 a5 d0 h0 f0 h0 w3 l0 w1 a5 w8 l00 w8 a2 w2 l5 t0 r1 c4',
        'bus4': 't0 w4 l4 d0 w8 a1 w8 w8 l000 w8 a4 d0 h0 c5',
        'bus5': 't0 d5 w2 a3 w2 l2 d5 j0 w2 a0 w2 l1 d5 w2 l3 w2 a3 d5 h0 c1',
        'bus6': 't0 w6 d6 w2 a0 w2 l1 d6 w0 l3 w2 w6 a3 d6 h0 c1'
    };
    
    return {
        imgType,
        get ["bus.sprites.css"]() {
            return cache["bus.sprites.css"] ??= _genSpritesCSS();
        },
        get sprites() {
            return cache['sprites'] ??= {
                _: `background-image: url(${imgType.file})/*livrey*/; font-size: 0; line-height: 47px;`,
                ..._genInlineSprites()
            };
        },
        get ["bus.gradients.css"]() {
            return cache['bus.gradients.css'] ??= LIVREYS.map(([id, {rules, note}]) =>`\
.${id},:checked[value="${id}"] ~ div .slot .shadow label { background-image: linear-gradient(to bottom, ${rules}); } /* ${note} */`).join('\n');
        },
        get livreys() {
            return cache['livreys'] ??= Object.fromEntries(
                LIVREYS.map(([id, { rules }]) => [id, `linear-gradient(to bottom, ${rules});`])
            );
        },
        get hints() {
            return cache['hints'] ??= Object.fromEntries(
                [...LIVREYS, ...SPRITES].map(([id, { note }]) => [id, note])
            );
        },
        SPRITES,
        genesys
    }
})();

const COLOR_RX = /\s*c\d+\s*/g;
const ELEMENT_RX = /\s+|(?<=\d+)(?=[a-z])/g;
const GROUP_RX = /.\d+\s*[al]\d+|.\d+/g;

function showBus(bus = SPEC.genesys['bus0']) {
    return styleBus(splitSides(bus));
}

function styleBus(busLayout) {
    const [colorElement, ...sides] = busLayout;
    
    const styleBottom = (bottomElement, topRules) => {
        let bottomRules = (SPEC.sprites[bottomElement[0]] || '') + SPEC.sprites[bottomElement];

        const [topWidth, bottomWidth] = [topRules, bottomRules]
            .map(rules => Number((rules.match(/padding-(left|right):\s*(\d+)px/) || [])[2]));

        const leftShift = Math.round(Math.max((topWidth + bottomWidth) / 2, bottomWidth));
        return bottomRules
            .replace(/margin-left:\s*(-?\d+)px;/, `margin-left: ${-leftShift}px;`)
            .replace(/padding-left:\s*(\d+)px;/, `padding-left: ${leftShift}px;`);
    };

    // Transform sides while keeping structured `{ top, bottom }` format
    const styledSides = sides.map(side =>
        side.map(([topElement, bottomElement]) => {
            const baseStyle = SPEC.sprites._.replace('/*livrey*/', `, ${SPEC.livreys[colorElement]}`);
            const topStyle = baseStyle + (SPEC.sprites[topElement[0]] || '') + SPEC.sprites[topElement];
            const bottomStyle = bottomElement ? baseStyle + styleBottom(bottomElement, topStyle) : null;

            return {
                top: { element: topElement, style: topStyle },
                ...(bottomElement ? { bottom: { element: bottomElement, style: bottomStyle } } : {})
            };
        })
    );

    return [colorElement, ...styledSides];
}

function consoleFormatter(busLayout) {
    const elements = [], styles = [];

    busLayout[0] && elements.push(`%c${busLayout[0]}`) && styles.push('font-size: 0');

    busLayout.slice(1)
        .flatMap(side => side.flatMap(({ top, bottom }) => [top, bottom].filter(Boolean))) // Flatten `top` & `bottom`
        .forEach(({ element, style }) => {
            elements.push(`%c${element}`);
            styles.push(style);
        });

    return [elements.join(' '), ...styles.map(rules => rules.replace(SPEC.imgType.file, SPEC.imgType.inline))];
}

function generateSideContent(busLayout, formatSlot) {
    const SIDE_MAP = ['right', 'front', 'left', 'rear', 'top', 'bottom', 'floor'];
    return busLayout.slice(1)
        .map((side, sideIndex) => {
            if (!side.length) return ''; // Skip empty sides
            const sideName = SIDE_MAP[sideIndex];
            const sideContent = side.map(formatSlot).join(' ');
            return `<div class="${sideName} face">${sideContent}</div>`;
        })
        .filter(Boolean)
        .join('\n');
}

/**
 * Keep styles inline with associated span, inflicting some overhead.
 */
function inlineFormatter(busLayout) {
    const colorElement = busLayout[0];
    const getSpan = (element, rules) =>
        `<span class="${element[0]} ${element} ${colorElement}" style="width: unset; display:inline-block; ${rules}">${element}</span>`;

    return [generateSideContent(busLayout, ({ top, bottom }) =>
        getSpan(top.element, top.style) +
        (bottom ? getSpan(bottom.element, bottom.style + ' background-image: url(tiles.png);') : '')
    ) + colorElement];
}

/**
 * Isolates CSS rules into bus-scoped <style/> block, allowing for optimization.
 */
function outlineFormatter(busLayout, id) {
    const styleSheet = new Set(); // Use Set directly for unique styles
    const colorElement = busLayout[0];
    const getElement = (element) => `<span class="${element[0]} ${element} ${colorElement}">${element}</span>`

    const html = generateSideContent(busLayout, ({ top, bottom }) => {
        const topSelector = `#${id} .${top.element[0]}.${top.element}`;
        styleSheet.add(`${topSelector} { ${top.style} }`);

        if (bottom) {
            styleSheet.add(`${topSelector} + .${bottom.element[0]}.${bottom.element} { ${bottom.style}; background-image: url(tiles.png); }`);
        }

        return getElement(top.element) + (bottom ? getElement(bottom.element) : '');
    });

    // Optimize style rules
    const livreyCss = SPEC.sprites._.replace('/*livrey*/', colorElement ? `, ${SPEC.livreys[colorElement]}` : '');
    const styleRules = Array.from(styleSheet).join('\n').replaceAll('/*top*/', '').replaceAll(livreyCss, '');

    // Wrap styles into a scoped `<style>` block
    const styleTag = `<style>\n#${id} span { width: unset; display:inline-block; ${livreyCss} }\n${styleRules}</style>\n`;
    return [html + colorElement, styleTag];
}

/**
 * Renders bus as a single strip of parts.
 */
function flatRenderer(html, styleTag) {
    return $("<a class='bus-view' />")
        .html(styleTag + html)
        .attr('href', '#' + encodeURIComponent($(`<span>${html}</span>`).text().replace(/\s+/g, '')));
}

/**
 * Renders bus in 3D.
 */
function fullRenderer(html, styleTag) {
    const bus = $(`<span>${html}</span>`).text();
    return $("<a class='bus-view paper-net' />")
        .append(
            styleTag,
            html,
            html.match(/c\d+/)?.[0] ?? "c1")
        .attr("href", "#" + encodeURIComponent(bus.replace(/\s+/g, "")));
}

/**
 * Splits bus source into 4+ sides.
 */
function splitSides(bus) {
    // Extract color if present
    const colorMatch = bus.match(/c\d+/g);
    const colorElement = colorMatch ? colorMatch[0] : 'c1';
    const cleanedBus = bus.replace(/c\d+/g, '').trim();

    // Tokenize bus elements into full groups before slicing
    const elementGroups = cleanedBus.match(GROUP_RX) || []; // Groups before splitting

    // Locate split points with corrected left-side handling
    const firstHeadIndex = elementGroups.findIndex(el => /^h\d+$/.test(el));
    const frontStartIndex = elementGroups.findIndex(el => /^f\d+$/.test(el));
    const secondHeadIndex = elementGroups.findIndex((el, i) => /^h\d+$/.test(el) && i > firstHeadIndex);
    const leftStartIndex = frontStartIndex !== -1 ? frontStartIndex + 1 : secondHeadIndex; // Start left after front or second `h`
    const leftEndIndex = elementGroups.findIndex((el, i) => /^r\d+$/.test(el) && i > leftStartIndex) - 1; // Ensure `r` is excluded
    const rightEndIndex = firstHeadIndex !== -1 
        ? firstHeadIndex + 1 // End at first `h` (included)
        : (frontStartIndex !== -1 ? frontStartIndex : -1); // End at first `f` (excluded), otherwise defer decision

    // Identify roof elements starting after the last rear (`r`)
    const rearEndIndex = elementGroups.findIndex(el => /^r\d+$/.test(el)) + 1;
    const roofStartIndex = elementGroups.findIndex((el, i) => /^s\d+$/.test(el) && i >= rearEndIndex);

    // Helper function to structure `[top, bottom?]` groups
    const groupElements = (list) => list.map(busGroup => {
        const matches = busGroup.match(/\w\d+/g) || [];
        const [topElement, bottomElement] = matches.length > 1 ? matches : [matches[0], undefined];
        return bottomElement ? [topElement, bottomElement] : [topElement];
    });

    // Extract structured sides
    const right = rightEndIndex !== -1 ? groupElements(elementGroups.slice(0, rightEndIndex)) : [];
    const front = groupElements(elementGroups.filter(el => /^f\d+$/.test(el)));
    const left = leftStartIndex !== -1 ? groupElements(elementGroups.slice(leftStartIndex, leftEndIndex !== -1 ? leftEndIndex + 1 : elementGroups.length)) : [];
    const rear = groupElements(elementGroups.filter(el => /^r\d+$/.test(el)));
    const roof = roofStartIndex !== -1 ? groupElements(elementGroups.slice(roofStartIndex)) : [];

    // Ensure no lost elements: fallback to right if all sides are empty
    if (!right.length && !front.length && !left.length && !rear.length && !roof.length) {
        return [colorElement, groupElements(elementGroups)];
    }

    return [colorElement, right, front, left, rear, roof]; // Add roof to output
}

function autocompleteSide(side, bus) {
    switch(side) {
        case "front":
            return either('f0', 'f1', 'f2');
        case 'rear':
            return 'r0';
    }
}

function parseAnnotations(docs) {
    const graph = {};

    docs.forEach(doc => {
        const name = doc.match(/function (\w+)/)?.[1];
        const depends = [...doc.matchAll(/@depends (\w+)/g)].map(match => match[1]);
        const usedBy = [...doc.matchAll(/@usedBy (\w+)/g)].map(match => match[1]);

        if (name) {
            graph[name] = { depends, usedBy };
        }
    });

    return graph;
}